# 一

``` javascript
var a = [];
for(let i = 0; i<10; i++) {
    a[i] = function() {
        console.log(i)
    }
}
a[6]()
```

运行结果为：10

原因：i是使用var声明，循环体中的i是全局作用域中的i，当循环结束时，全局作用域中的i变成了10，所以结果为10。

# 二、

``` javascript
var tmp = 123;
if(true) {
    console.log(tmp)
    let tmp
}
```

运行结果：报错

原因：if语句花括号中的语句在块级作用域中，块级作用域中使用let定义了tmp，let不允许变量提升，必须先声明在使用。

# 三、结合ES6新语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
let tmp = arr[0]
for (const item of arr) {
    if (tmp > item) {
        tmp = item
    }
}
console.log(tmp)
```

# 四、

1. var与let可以声明变量，const不能声明变量，只能声明只读的常量。
2. var声明的变量不存在块级作用域，在全局内有效。let与const的声明只在其所在的代码块中有效。
3. let/const不能在同一个作用域中声明相同变量/常量，var可以多次重复声明。
4. var存在变量提升，可以先使用在声明，let/const必须先声明在使用。
5. let/const会出现暂时性死区。
6. const声明时必须初始化赋值，一旦声明其赋值的值不允许被改变。

# 五、

```javascript
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(() =>{
            console.log(this.a)
        })
    }
}
obj.fn()
```

运行结果：20

原因：setTimeout中传入的是一个箭头函数，this指向obj。

# 六、简述symbol类型的用途

用来定义函数的私有属性。

# 七、说说什么是浅拷贝，什么是深拷贝

浅拷贝：浅拷贝新对象只会精确拷贝原始对象的基本类型的值，对于引用类型，拷贝的就是内存地址，如果其中一个对象改变了这个地址的值，就会影响到另一个对象。

深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份儿出来，在堆内存中开辟一个新的区域存放新对象。修改新对象不会影响原对象。

# 八、请简述TypeScript与JavaScript之间的关系
TypeScript是 JavaScript 的超集，包含了 JavaScript 的所有元素。

# 九、请谈谈你所认为的TypeScript优缺点
## 优点
- 增加了代码的可读性和可维护性
- 编译阶段就可以发现大部分错误

## 缺点
- 有一定学习成本
- 增加了额外的代码量
- 构建流程较为麻烦，没有Javascript

# 十、描述引用计数的工作原理和优缺点

工作原理：记录对象的引用次数，当引用次数为0时，GC立刻工作将当前对象回收。

优点：垃圾回收快，程序暂停时间短。

缺点：无法回收循环引用对象。

# 十一、描述标记整理算法的工作流程

第一阶段：使用标记清除算法将作用域中的所有可达对象进行标记。
第二阶段：整理对象，在内存地址上连续，然后进行清除操作。

# 十二、描述V8中新生代存储区垃圾回收的流程。
1. V8内存空间一分为二，新生代（32M|16M）存活时间较短的，老生代。
2. 新生代分为from与to两块内存空间。触发回收时使用标记整理算法将from空间的对象复制到to空间，完成后交换from与to空间。
3. 当新生代的一个对象经过一轮GC依然存活，就会被认为是生命周期较长的对象，随后会被移动到老生代中。
4. 结合使用标记清除和标记整理算法回收老生代的未存活对象。

